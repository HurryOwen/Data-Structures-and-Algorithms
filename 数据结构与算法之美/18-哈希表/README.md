## 散列思想

**散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表**

## 散列函数

顾名思义，是一个函数。我们可以把它定义成**hash(key)**，其中 key 表示元素的键值， hash(key)的值表示经过散列函数计算得到的散列值。

```
int hash(String key) {
  // 获取后两位字符
  string lastTwoChars = key.substr(length-2, length);
  // 将后两位字符转换为整数
  int hashValue = convert lastTwoChas to int-type;
  return hashValue;
}
```

### 散列函数设计的基本要求

- 1、散列函数计算得到的散列值是一个非负整数；
- 2、如果 `key 1 = key 2`，那 `hash(key 1) == hash(key 2)`;
- 3、如果 `key 1 ≠ key 2`， 那 `hash(key 1) ≠ hash(key 2)`;

着重说明第 3 点，在真实情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便是业界著名的 MD5、SHA、CRC 等哈希算法，也无法完全避免这种散列冲突。

所以我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。

## 散列冲突

### 1、开放寻址法

开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。
探测新位置的方法：

- 线性探测（Linear Probing），如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。
- 二次探测（Quadratic Probing）
- 双重散列（Double hashing）

![线性探测](./images/线性探测法.jpg)

不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用**装载因子**来表示空位的多少。

装载因子的计算公式是：

> 散列表的装载因子=填入表中的元素个数/散列表的长度
> 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

### 2、链表法

链表法是一个更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

![链表法](./images/链表法.jpg)
