## 归并排序

**归并排序核心思想就是分治思想**，顾名思义就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。如果要排序一个数组
我们把数组从中间分成前后两部分，然后对前后两部分两两分别进行排序，再讲排好序的两部分两两合并在一起，这样整个数组就有序了。

![归并排序](./images/归并排序.jpg)

分治算法一般都是用递归来实现。分治是一种解决问题的处理思想，递归是一种编程技巧。

递归代码的编写技巧：1、分析得出递推公式；2、找到终止条件；3、将递推公式翻译成递归代码

```
// 递推公式
merge_sort(p...r) = merge(merge_sort(p...q),merge_sort(q+1...r))

// merge_sort(p...r)表示，给下标从p到r之间的数组排序。
// merge 就是将已经有序的两个数组合并成一个有序数组

// 终止条件
p >= r 不用再继续分解

```

![归并排序](./images/归并过程.jpg)

代码实现见[归并排序实现](./mergeSort.js)

## 快速排序

**原理**：快速排序利用的也是分治思想。其核心思想是，如果要排序树组下标从 p 到 r 之间的一组数据，我们选择从 p 到 r 之间的任意一个数组作为 pivot（分区点）。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，大于 pivot 的放到右边，将 pivot 放到中间。
![快速排序](./images/快速排序.jpg)

```
// 递推公式
quick_sort(p...r) = quick_sort(p...q-1) + quick_sort(q+1...r);

// 终止条件

p >= r

```

伪代码

```

// 快速排序，A是数组，n表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r为下标
quick_sort_c(A, p, r) {
  if p >= r then return

  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}

```

归并排序有一个 merge()合并函数，快速排序有一个 partition() 分区函数。

如果不考虑空间消耗的话，partition()分区函数可以写的非常简单。可以申请两个临时数组 X 和 Y,遍历 A[p...r]，将小于 pivot 的元素都拷贝到临时数组 X，大于 pivot 的元素拷贝到数组 Y，最后将数组 X 和数组 Y 中数据顺序拷贝到 A[p...r]。

但是这种实现思路，partition()函数需要很多额外的内存空间
