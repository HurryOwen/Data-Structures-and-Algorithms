## 桶排序（Bucket sort）

核心思想是要讲排序的数据分到几个有序的桶里，每个桶里的数据再单据进行排序。桶内排完序后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

![桶排序](./images/桶排序.jpg)

桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将全部数据全部加载到内存中。

## 计数排序(Counting sort)

**计数排序是桶排序的一种特殊情况。**当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们可以把数据分成 k 个桶。每个桶内的数据都是相同，省掉了桶内排序的时间。
比如有 8 个考生成绩分数在 0-5 之间，放在一个数组 A[8]中，分别是 2,5,3,0,2,3,0,3。考生成绩从 0 到 5，我们使用大小为 6 的数组 C[6]表示桶，其下标对应分数。C[6]内存储考生个数。C[6]=[2,0,2,3,0,1] 即 C[3]=3 表示分数为 3 的考生有 3 个。

![计数排序](./images/计数排序1.jpg)

从上图可以看出，分数为 3 的考生有 3 个，小于 3 分的考生有 4 个。所以成绩为 3 分的考生在排序后的有序数组 R[8]中，会保存下标 4，5，6 的位置。

![计数排序](./images/计数排序2.jpg)

那如何算出每个分数的考生在有序数组中对应的存储位置呢？这个方法非常巧妙。
思路是这样：我们对 C[6]数组顺序求和，C[6]存储的数据变成了小于等于该位置分数的考生个数，比如 C[k]=3,则代表分数小于等于 k 的考生有 3 个。

![计数排序](./images/计数排序3.jpg)

然后我们从后向前依次扫描数组 A。当扫描到 3 时，从数组 C 中取出下标为 3 的值 7，也就是说，现在分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素。当把 3 放入到数组 R 之后，小于等于 3 的元素就只剩下 6 个了，所以相应的 C[3]要减 1，变成 6。以此类推。当扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。

![计数排序](./images/计数排序4.jpg)
