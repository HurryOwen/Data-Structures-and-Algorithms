## 线性表的定义
> 线性表（List）:零个或多个数据元素的有限序列。

关键点：
- **有序**。元素之间是有顺序的，若有多个元素，则第一个元素没有前驱，最后一个元素没有后继，其他元素都有且仅有一个前驱和一个后继。
- **有限**。元素的个数有限。

## 线性表的顺序存储结构
### 顺序存储的定义
> 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

可以用C语言中的一维数组来实现线性表的顺序存储结构。
### 顺序存储方式
先来看看顺序存储的结构代码
```
#define MAXSIZE 20 /*存储空间初始分配量*/
typedef int ElementType; /*假设ElementType 为int */
typedef struct
{
    ElemType data[MAXSIZE]; /*数组存储数据元素，最大值为MAXSIZE*/
    int length; /*线性表当前长度*/
}sqlList;

```
### 数组长度与线性表长度的区别
数组的长度是存放线性表的存储空间的长度，存储分配后一般这个值是不变的。

线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个值是变化的
### 地址计算方法
存储器中每个存储单元都有自己的编号，这个编号成为地址。

假设每个数据元素占据c个存储单元，那么线性表中第i+1个数据元素的存储位置，与第i个数据元素的存储单位满足

LOC(a<sub>i+1</sub>) = LOC(a<sub>i</sub>)+c

所以第i个元素的位置可以由一下公式得出：

LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>)+（i -1）* c

通过这个公式，可以随时算出线性表中任意位置的地址。无论是对线性表进行存入还是取出数据，都是花费相同的常数的时间，时间复杂度为O(1)，我们称这样的存储结构为随机存取结构。

### 顺序存储结构的插入与删除操作
#### 获得元素操作
>时间复杂度为O(1)

对于线性表的顺序存储结构，只要i合理，要把线性表的第i个元素的地址返回，就是把数据第`i-1`下标的值返回。
#### 插入元素
>时间复杂度为O(n)

插入算法的思路：
- 如果插入位置不合理，抛出异常
- 如果线性表长度大于数组长度，抛出异常或者动态扩容
- 从最后一个元素开始遍历到第i个位置，分别将他们都向后移一个位置
- 将要插入的元素填入i处
- 表长加1

#### 删除元素
> 时间复杂度为O(n)

删除算法的思路：
- 如果删除位置不合理，抛出异常；
- 取出删除元素
- 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
- 表长减1

#### 线性存储结构的优缺点
**优点：**
- 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
- 可以快速地存取表中任一位置的元素

**缺点：**
- 插入和删除操作需要移动大量元素
- 当线性表长度变化较大时，难以确定存储空间的容量
- 造成存储空间“碎片”

## 线性表的链式存储结构 
### 线性表链式存储结构的定义

为了表示每个数据元素a<sub>i</sub>与其直接后继数据元素a<sub>i+1</sub>之间的逻辑关系，对数据元素a<sub>i</sub>来说，除了存储本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素a<sub>i</sub>的存储映像，称为节点（Node）。
n个节点（a<sub>i</sub>的存储映像）链结成一个链表，即为线性表（a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n</sub>）的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫做单链表。
### 单链表的读取
> 时间复杂度为O(n)

获得链表第i个数据的算法思路：
- 1、声明一个节点P指向链表第一个节点，初始化j从i开始
- 2、当j<i时，就遍历链表，让P的指针向后移动，不断指向下一个节点，j累计加1；
- 3、若到链表末尾p为空，则说明第i个元素不存在；
- 4、否则查找成功，返回节点P的数据

### 单链表的插入与删除

单链表第i个数据插入节点的算法思路：
- 1、声明一结点P指向链表第一个结点，初始化j从1开始；
- 2、当j<i时，就遍历链表，让P的指针向后移动，不断指向下一结点，j累加1；
- 3、若到链尾P为空，则说明第i个元素不存在；
- 4、否则查找成功，在系统中生成一个空节点s；
- 5、将数据元素e赋值给`s->data`；
- 6、单链表的插入标准语句`s->next=p->next; p->next=s;`
- 7、返回成功

### 单链表的删除

单链表第i个数据删除结点的算法思路：
- 1、声明一结点P指向链表第一个结点，初始化j从1开始；
- 2、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
- 3、若到链表末尾p为空，则说明第i个元素不存在；
- 4、否则查找成功，将欲删除的节点`p->next`赋值给q;
- 5、单链表的删除标准语句`p->next=q->next`；
- 6、将q结点中的数据赋值给e，作为返回；
- 7、释放q结点；
- 8、返回成功。

### 单链表的整表创建
（头插法）算法思路：
- 1、声明一结点P和计数器变量i；
- 2、初始化一空链表L;
- 3、让L的头结点的指针指向NULL，即建立一个带头结点的单链表；
- 4、循环：
    - 生成一新结点赋值给p；
    - 随机生成一数字赋值给p的数据域p->data;
    - 将p插入到头结点与前一新结点之间。
（尾插法）算法思路：
- 1、声明两结点P、r和计数器变量i；
- 2、初始化一空链表L;
- 3、让L的头结点的指针指向NULL，即建立一个带头结点的单链表。
- 4、r指向尾部的结点
- 5、循环：
    - 生成新结点赋给P
    - 随机生成一数字赋值给P的数据域p->elem；
    - 将p插入到尾结点r之后；
    - 更新尾结点r指向p；
- 6、将r的指针置为NULL，以便以后遍历时确认是尾部。

### 单链表的整表删除
算法思路：
1、声明一结点P和q；
2、将第一个结点赋值给p；
3、循环：
    - 将下一结点赋值给q
    - 释放p
    - 将q赋值给p
## 单链表结构与顺序存储结构优缺点：
###1、存储分配方式
- 顺序存储结构用一段连续的存储单元一次存储线性表的数据元素
- 单链表采用链式存储结构，用一组任一的存储单元存放线性表的元素
###2、时间性能
- 查找
 - 顺序存储结构O(1)
 - 单链表O(n)
- 插入和删除
 - 顺序存储结构需要平均移动表长一半的元素，时间为O(n)
 - 单链表在找出某位置的指针后，插入和删除时间仅为O(1)
###3、空间性能
- 顺序存储结构需要预分配存储空间。分大了会浪费，分小了容易发生上溢
- 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。

###总结
- 1、若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。
- 2、当线性表中的元素个数变化较大或根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小。而如果实现知道线性表的大致长度，比如一年12个月，这种用顺序存储结构效率会高很多。

## 单向循环链表
> 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。

为了使空链表与非空链表处理一致，我们通常设一个头结点。

其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断`p->next`是否为空，现在则是`p->next`不等于头结点，则循环未结束。
### 合并两个循环链表（带尾指针）
算法：
- 1、保存A表的头结点，赋值给p
- 2、将本是指向B表的第一个结点（不是头结点）赋值给reaA->next
- 3、将原A表的头结点赋值给reaB->next
- 4、释放p结点
```
p = reaA->nxt; /*1*/
reaA->next = reaB->next->next; /*2*/
reaB->next =p; /*3*/
free(p);
```

### 双向链表

在单链表中，查找下一结点的时间复杂度为O(1)，但是如果查找上一结点，时间复杂度为O(n)。
为了克服单向性的这一缺点，设计了双向链表。
> 双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。







