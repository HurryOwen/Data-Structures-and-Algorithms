## 串
> 由零个或多个字符组成的有限序列，又名叫字符串。
### 串的顺序存储结构
串值的存储空间可在程序执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做“堆”。这个堆可由C语言动态分配函数`malloc()`和`free()`来管理。
### 串的链式存储
由于串结构的特殊性，结构中的每个元素数据是一个字符，如果只是简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此可以一个结点可以存放一个字符，也可以考虑多个字符，最后一个结点若是未占满时，可以用“#”或其他非串值字符补全。

一个结点存多少个字符直接影响着串的存储效率，需根据实际情况做出选择。但是串的链式存储除了在连接串与串操作时有一定方便外，总的来说不如顺序存储灵活，性能也不如顺序存储好。
### 朴素的模式匹配算法
> 子串的定位操作通常称作串的匹配模式
```
/*假设主串S和子串T的长度存在S[0]和T[0]中*/
/*返回子串在T在主串S中第pos个字符之后的位置。若不存在，则返回值为0*/
/*T非空，1=< pos >= StrLength(S)*/
int Index (String S, String T, int pos)
{
    int i = pos;
    int j = 1;
    while(i<=S[0]&& j<=T[0])
    {
        if(S[i]===T[j])
            i++;
            j++;
        else{
            i = i-j+2;
            j=1
        }
    }
    if(j>T[0])
        return i-T[0]
    else
        return 0
}
```
> 最坏情况下，复杂度为O((n-m+1)*m),效率低下
### KMP模式匹配算法
> next数组，next[q]=k表示，在T[q]之前的子串中，存在长度为K-1的相同前缀和后缀。

即P<sub>1</sub>...P<sub>k-1</sub>=P<sub>q-k+1</sub>...P<sub>q-1</sub>

```
/*通过计算返回子串T的next数组*/
void get_next (String T, int *next)
{
    int i,j;
    i = 1;
    j = 0;
    next[1] = 0;
    while (i<T[0]) /*T(0)表示串T的长度*/
    {
        if(j==0 || T[i] == T[j])
        {
            ++i;
            ++j;
            next[i]=j;
        }
        else{
            j = next[j];/*若字符不相同，则j值回溯*/
        }
    }
}
```